#!/usr/bin/env python

import rospy
import sys
from std_msgs.msg import String, Float32
from std_srvs.srv import Trigger
#from motor_loop_qt_demo.custom_spin_box import *
from PySide2.QtCore import *
from PySide2.QtGui import *
from PySide2.QtWidgets import *

from raspbioloid_gui import GUI, custom_spin_box
from motors.msg import *
from mopi_msgs.srv import *
from mopi_msgs.msg import *

from sensor_msgs.msg import Imu

from motors.msg import *
from motors.srv import *


class Application(QMainWindow):
  statusReceived = Signal(int, int, int, bool)
  imuReceived = Signal(Imu)
  def __init__(self):
    super(Application, self).__init__()
    self.ui = GUI.Ui_MainWindow()
    self.ui.setupUi(self)
    
    self.spinboxes =  [self.ui.m_01_spinbox, self.ui.m_02_spinbox, self.ui.m_03_spinbox, self.ui.m_04_spinbox,
                       self.ui.m_05_spinbox, self.ui.m_06_spinbox, self.ui.m_07_spinbox, self.ui.m_08_spinbox, 
                       self.ui.m_09_spinbox, self.ui.m_10_spinbox, self.ui.m_11_spinbox, self.ui.m_12_spinbox,
                       self.ui.m_13_spinbox, self.ui.m_14_spinbox, self.ui.m_15_spinbox, self.ui.m_16_spinbox, 
                       self.ui.m_17_spinbox, self.ui.m_18_spinbox]
    self.checkboxes = [self.ui.lock_01, self.ui.lock_02, self.ui.lock_03, self.ui.lock_04,
                       self.ui.lock_05, self.ui.lock_06, self.ui.lock_07, self.ui.lock_08, 
                       self.ui.lock_09, self.ui.lock_10, self.ui.lock_11, self.ui.lock_12,
                       self.ui.lock_13, self.ui.lock_14, self.ui.lock_15, self.ui.lock_16, 
                       self.ui.lock_17, self.ui.lock_18]

    rospy.init_node('raspbioloid_control_panel', anonymous=True)


    rospy.wait_for_service("move_motor")
    self.move_srv = rospy.ServiceProxy("move_motor", MoveMotor)

    rospy.wait_for_service("torque_motor")
    self.torque_srv = rospy.ServiceProxy("torque_motor", Torque)
    
    rospy.wait_for_service("torque_all")
    self.torque_all_srv = rospy.ServiceProxy("torque_all", TorqueAll)
    print self.torque_all_srv


    for i in range(1, 19):
      rospy.Subscriber("/motors_info/%d" % i,
                       MotorMsg, 
                       lambda msg, i=i, p = self.statusReceived: p.emit(i-1, msg.Pos, msg.Load, msg.Locked))
                   
      #TODO: implement speed
      self.spinboxes[i-1].enterKeyPressed.connect(lambda degrees, i=i, f=self.set_goal: f(i, degrees/360.0*1024, 100))
      self.checkboxes[i-1].stateChanged.connect(lambda checked, i=i, f=self.set_torque: f(i, checked))

    self.statusReceived.connect(self.consume)

    rospy.Subscriber("/imu/data",
                       Imu, 
                       lambda msg, i=i, p = self.imuReceived: p.emit(msg))    
                       
    self.imuReceived.connect(self.update_imu_status)
    
    print self.ui.button_lock_all.clicked
    
    self.ui.button_lock_all.clicked.connect(self.lock_all)
    self.ui.button_unlock_all.clicked.connect(self.unlock_all)
    
    self.ui.anim1.clicked.connect(self.anim1)
    
    self.setUpdatesEnabled(False)
    self.redraw_timer = QTimer()
    self.redraw_timer.timeout.connect(self.redraw)
    self.redraw_timer.start(40)

  def redraw(self):
    self.setUpdatesEnabled(True)
    self.repaint()
    self.setUpdatesEnabled(False)
    
  def set_torque(self, dxl_id, lock):
    self.torque_srv(dxl_id, lock!=0)
    
  def lock_all(self):
    self.torque_all_srv(True)
    
  def unlock_all(self):
    self.torque_all_srv(False)
    
  def set_goal(self, dxl_id, pos, speed):
    self.move_srv(dxl_id, pos, speed)
    
  def anim1(self):
    self.torque_all_srv(True)

  def consume(self, dxl_id, pos, load, locked):
    self.spinboxes[dxl_id].setStatus(pos, load if not locked else 0)
    self.checkboxes[dxl_id].setCheckState(Qt.CheckState.Checked if locked else Qt.CheckState.Unchecked)
        
    #rospy.Subscriber("imu/data",
    #                 Imu, 
    #                 self.update_imu_status, queue_size=1)


    ## MOPI
    #rospy.Subscriber("battery_lvl",
    #                 Float32, 
    #                 lambda res: self.ui.voltage.setText("%.2f V" % res.data))

    #rospy.wait_for_service("mopi_status_trigger")
    #rospy.ServiceProxy("mopi_status_trigger", Trigger)()
    
    #rospy.wait_for_service("mopi_info")
    #self.mopi_info_srv = rospy.ServiceProxy("mopi_info", MopiInfo)
    #self.mopi_info_srv.timer = QTimer()
    #self.mopi_info_srv.timer.timeout.connect(self.update_batt_info)
    #self.mopi_info_srv.timer.start(1000)
    
    #self.update_batt_info()

    ## IMU

#  def update_batt_info(self):
#    info = self.mopi_info_srv()
#    self.setUpdatesEnabled(False)
#    self.ui.fw_ver.setText("%d.%d" % (info.mayor_ver, info.minor_ver))
#    self.ui.active.setText("%r" % info.status.active)
#    self.ui.profile.setText(info.status.profile)
#    self.ui.good.setText("%r" % info.status.good)
#    self.ui.src_type.setText(info.cnf.src_type)
#    self.ui.max_v.setText("%.2f V" % info.cnf.lvls.maximum)
#    self.ui.good_v.setText("%.2f V" % info.cnf.lvls.good)
#    self.ui.low_v.setText("%.2f V" % info.cnf.lvls.low)
#    self.ui.critical_v.setText("%.2f V" % info.cnf.lvls.critical)
#    self.setUpdatesEnabled(True)


  def update_imu_status(self, mes):
    o = mes.orientation
    av = mes.angular_velocity
    la = mes.linear_acceleration
    self.setUpdatesEnabled(False)
    self.ui.position_x.setText("x: %.3f" % o.x)
    self.ui.position_y.setText("y: %.3f" % o.y)
    self.ui.position_z.setText("z: %.3f" % o.z)
    self.ui.speed_x.setText("x: %.3f" % av.x)
    self.ui.speed_y.setText("y: %.3f" % av.y)
    self.ui.speed_z.setText("z: %.3f" % av.z)
    self.ui.acceleration_x.setText("x: %.3f" % la.x)
    self.ui.acceleration_y.setText("y: %.3f" % la.y)
    self.ui.acceleration_z.setText("z: %.3f" % la.z)
    self.setUpdatesEnabled(True)
                
def main():
  print "Avvio"
  app = QApplication(sys.argv)
  form = Application()
  form.show()
  app.exec_()

if __name__ == '__main__':
  try:
    main()
  except rospy.ROSInterruptException:
    pass
